---
layout:     post                    # 使用的布局（不需要改）
title:      九度OJ题目1131              # 标题 
subtitle:   合唱队形  #副标题
date:       2019-04-02              # 时间
author:     qyl                      # 作者
header-img: img/post-bg-c.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 编程题
    - 最长递增子序列
---

**题目描述：** 
N位同学站成一排，音乐老师要请其中的(N-K)位同学出列，使得剩下的K位同学不交换位置就能排成合唱队形。
 合唱队形是指这样的一种队形：设K位同学从左到右依次编号为1, 2, …, K，他们的身高分别为T1, T2, …, TK，
 则他们的身高满足T1 < T2 < … < Ti , Ti > Ti+1 > … > TK (1 <= i <= K)。
 你的任务是，已知所有N位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。
**输入：** 
输入的第一行是一个整数N（2 <= N <= 100），表示同学的总数。
第一行有n个整数，用空格分隔，第i个整数Ti（130 <= Ti <= 230）是第i位同学的身高（厘米）。
**输出：** 
可能包括多组测试数据，对于每组数据，
 输出包括一行，这一行只包含一个整数，就是最少需要几位同学出列。
**样例输入：**
 8
186 186 150 200 160 130 197 220
**样例输出：**
 4
**思路：**
最少挑出几人，即立下的合唱队形，最长多长
合唱队形，从两头看分别是一个递增子序列，只是本题要求两头加起来最长，从两个方向，分别查找最长递增子序列，两头求和取最大值

```cpp
#include<stdio.h>
int main(){
	int n;
	int h[101];
	while(scanf("%d",&n)!=EOF){
		for(int i=1;i<=n;i++){
			scanf("%d",&h[i]);
		}
		int num1[101];
		int num2[101];
		num1[1]=1;
		num2[n]=1;
		for(int i=2;i<=n;i++){
			int max=1;
			for(int j=1;j<i;j++){
				if(h[j]<h[i])
					max=num1[j]+1;
			}
			num1[i]=max;
		}
		for(int i=n-1;i>=1;i--){
			int max=1;
			for(int j=n;j>i;j--){
				if(h[j]<h[i])
					max=num2[j]+1;
			}
			num2[i]=max;
		}
		int cnt=0;
		for(int i=1;i<=n;i++){
			if((num1[i]+num2[i])>cnt)
				cnt=num1[i]+num2[i]-1;
		}
		printf("%d\n",n-cnt);
	}
	return 0;
}
```

